# -*- coding: utf-8 -*-
"""Lab1_03121098.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15J92tlUXECmBk3u4gdkwue1iAo1IoESh

# Τεχνολογίες Ανάλυσης Εικόνας και Βίντεο (2024-25)
**1η Εργαστηριακή Άσκηση**

Ονοματεπώνυμο: Λάππας Νικόλαος

Αριθμός Μητρώου: 03121098

# Θεωρητικό Μέρος

Έχοντας διαβάσει το άρθρο http://persci.mit.edu/pub_pdfs/pyramid83.pdf με τίτλο "The Laplacian Pyramid as a Compact Image Code" των Burt, P. J. and Adelson, E. H. περνάμε στην τεκμηριωμένη απάντηση των δοθέντων ερωτήσεων.

α) Ερώτηση: Πώς η τιμή του a επηρεάζει την γκαουσιανή πυραμίδα;

Απάντηση: Η παράμετρος a σχετίζεται με την διαμόρφωση της συνάρτησης στάθμισης που χρησιμοποιείται για την εξομάλυνση της εικόνας σε κάθε επίπεδο  της πυραμίδας. Η επιλογή της τιμής του a επηρεάζει το εύρος και το σχήμα της συνάρτησης στάθμισης, καθορίζοντας τον βαθμό εξομάλυνσης που εφαρμόζεται στην εικόνα. Για μεγάλες τιμές του a, η εικόνα γίνεται πιο θολή και ατονίζουν οι λεπτομέρειες, ενώ για μικρές τιμές του a η εικόνα διατηρεί περισσότερες λεπτομέρειες.

![weighted_func.png](data:image/png;base64,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i0pMTAxff/01zzzzjBY8ffr0YezYsdp+bdu2LRUrVqRVq1ba68xPp06dtP8H17/b7c432PJb/5NPPsnUqVMD3iTasWMHn332md+cl9apUyfWrl0bcLI6deoU27Zt44EHHggom982+N+euOWWW2jYsCF5eXl+c4U+/YgRI0YEjwwFq1at0hrY7t27WblyJZMnT+ahhx7ikUce4euvv2bz5s3k5OQwefJk0tPTGTt2LEajkdtuu43//ve/rF+/nqNHjzJjxgzuuOMOGjZsyF9//cV///tf9u/fT/369bUzaHJyMp999hkPPvggjRo1AuDIkSP06dOHzp07U7FiRfDdq1q4cCELFy6kdu3afPHFFxw8eJATJ06wcuVKvvvuOxITE7HZbPluf/Pmzfn22285fvw4bdu2BaBp06akpKTQtGlT7T6O2nsMDw+nUaNGmEwmbd+oKlSowJtvvsnw4cOpVKkSBoOB7du3k5ycrH3k4KuvvuKXX37B6XSyevVqVq5cqb37+dlnn7FmzRqqVavGHXfcQatWrRg8eDCpqans27ePadOm8eijj9KoUSMmTJjA0qVLueuuu6hWrRoZGRmMHTuWw4cP06JFC+Lj41m9erX2mu+8807i4+Mv2N8//fQTa9asoVWrVkRFRVGxYkVOnTqFzWbj/vvvp3HjxuzZs4dPPvkEm83GggULOHnyJH379g24vFu5ciVTpkwBoEGDBgH3+JKTk3njjTc4efIkO3fuZPLkyfTv31975/RS609OTgZg6NChWCwWli1bxpYtWxg6dCh6vZ6DBw8yceJE/vrrL26//XYqVqxIRkZGwL5s0qQJVatWZejQoXg8HrZu3cqIESP4+OOPqVev3mW3YdWqVXz77bdYLBa+++47MjIyeOONNwLumYa6kP0cW0FkZmZy//3307dvX5599tngyZw7d47MzEwqVaqE2WwOnnyBEydOkJiYSFhYWPCkIuPxeMjNzQUIOFBzc3PR6/VERET4lb68AwcOUKVKFfR6PQBnz57FbDbne4+noE6cOIHVaiU5OVlbblHJzs5GCEFUVJR2oLpcLnJzcwM+cmO1WklNTaVkyZIXvKFREB6Ph1OnTuF2u6lQoYL2Ogq6frvdrq2/RIkS2vgr4fF4OHLkCDqdjkqVKmlvJhRkG7Kysjhz5sw/fv03u2IdbADnz5/ntddeIyEhgfLlyzNgwIDgIpIk3WSKfbBJkhR6is2bB5IkFR8y2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjky2CRJCjmX/QXdy0yWpAsoiqL9X7Yf6Z/yb0dXSvbYpCJVmMYoSUVFBptUZBRFwe12M2/ePL7++mtyc3Nl0EnXhbwUlYqMoihs2LCBjh074nQ6Wbp0qfaMVdmOpCtVmJOi7LFJRUJthAcOHCA9PR2Xy6WNk6EmXWsy2KQipYZYWFgYRqMxeLIkXRMy2KQilZ2dDUB8fDwxMTHBkyXpmpDBJhUZr9dLeno6AOXKlZPBJl03MtikIuPxeMjNzQXAbDYX6uavJBWGDDbpqoiPj8dkMgWPlqRrQgabVGTcbjcWiwWAo0ePYrVag4tI0jUhg00qMoqiaJefERER6PX64CKSdE3IYJOKjE6nIyIiAuRn16TrTAabVGTcbjeZmZkAHDx4kIyMjOAiknRNyGCTikxWVhZ//fUXAHa7HbvdHlxEkq4JGWxSoan31fbu3cvff/8NgNVqJSsrK2C6JF0rMtikInPw4EFsNhsALpeLU6dOBReRpGtCBptUZDZu3Ijb7QZfsB09ejS4iCRdEzLYpCKRlpbG5s2bAYiKigJg//79eDyeoJKSdPXJYJOKxObNmzl+/Dj33HMPgwcPJiYmhm3btnH27NngopJ01clgk4rEpk2byM7O5q677uKJJ56gRIkSHDt2TF6OSteFDDapUBRFwWq1smPHDgBq1qxJ1apVadCgAWazWfbYpOtCBptUaJs3b2bjxo2ULFmS+vXrA9CxY0fCwsLYtm1bcHFJuupksEn/mPr5tA0bNnDmzBlq165NlSpVALj11ltJS0tj1apVWCwW+Vk26ZqSwSYVSl5eHrt37wagZcuWxMXFAVC9enVuu+02du7cycaNG4PmkqSrSwabVCi5ubns3LmTyMhI2rRpo42Pjo6mdu3a5OTk8Msvv+D1emWvTbpmZLBJ/4gaUjt27GDPnj3861//okGDBtp0o9FInTp1AFi+fDnHjh3TpknS1SaDTfrH8vLyGDNmDAC1a9fGaDQG/FxR3bp1iY+PZ/fu3Rw6dAjk90ala0QGm/SPrV27lnXr1mEymahatao2Xg23evXqcdddd+HxeNi6davfnJJ0dclgk66Y2utaunQpVquVjh070rZt2+BilCxZkvvvvx+A+fPnc+7cueAiknRVyGCT/pEDBw7w66+/AtC6dWvCw8MDLkPV/z/44IPau6MHDhzQpkvS1SSDTboiam9t0aJF7Nmzh7Jly9K6devgYppq1arxzDPPEB0dzZo1a0DeZ5OuARls0hWz2+3aZ9Pat29P9erVg4uAX6+tXbt2AHzxxRey1yZdEzLYpCu2detWFixYQPXq1RkyZAhc5uEtNWrUoFatWhw+fJgZM2aA7LVJV5kMNqnA1DBasmQJeXl59O7dm9tuuy242AVMJhNPPPEEACtXruT06dPBRSSpSMlgk67Ivn37+OWXX0hMTNS+8H6p3po67b777qN69er88ccf8l6bdNXJYJMKRA2hmTNnsm3bNlq2bEmTJk2Ci11UbGwstWrVAmDSpEmcP38+uIgkFRkZbFKBpaWlsWTJEgDatGlDWFjYJXtr/qKionj66acxGo0sX76c7du3g+y1SVeJDDbpstTwmTRpEps3b6Z27do88MADwcUuyv/d0a5du4LvHVL1iVaSVNRksEkFkpqayvfffw/Ac889xy233BJc5JKEEJjNZnr16kVCQgJz5szR3iGVpKImg026JLW3tn79evbs2UPjxo21dzgLehnqr0WLFjz++OMAfPPNN5w9e1ZejkpFTgabdFkWi0X7+tS//vUvEhMTg4sUiBqEgwYNokqVKqxbt47ffvstuJgkFZoMNumi1J7U/PnzmTVrFuXLl6dly5bwD3trquTkZJ544gm8Xi/z5s0jOztb9tpuQoqiBAyXElz2cuULSwabdElpaWlMnToVh8NBx44dtR+P/KfUQOzcuTOxsbEsXryY48ePBxeTbmAXC6b8xvEPxhcFGWzSJU2bNo3ly5cDcO+996LX6wvVW1PVr1+fAQMGYLFYWLZsGVzlhi4VrePHj/PGG2/Qpk0bevfufdmP7+zdu5cXX3yRpk2bMnjw4Kv+w6OKuEwrvcxkKUQpioLFYqF9+/asXr2aHj16MHXqVMxmc5G0CUVROH/+PB07dmT//v1s3ryZypUrF8mypYsHRmH3r6IonD59mt69e7Ny5UpuueUW0tLSiI2NZebMmTRu3DhgHYqisH37dnr16sXhw4cpU6YMBw4coHbt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OH36NE899RQbN26kTJkyeDweFEXhjTfeuOzJLL/XUFAy2KRLUhvnk08+ye+//87y5ctp2bJloduF2mgHDx7M2LFj6dKlC1988QUJCQmFXnZxpu7XkydPsnbtWrKysihdujR33303pUqVumDfXi48gntge/fupX79+txxxx0sXbqUffv20axZM5o3b86MGTNITEwMCLa//vqLhx56iMcff5znn38ep9OJy+UiPj6e2NhYvzVd6HLbdinyxoZ0UWrD+vrrr/n999/p2bMnd999d3Cxf0Rt/P3796dq1ar89NNPfPPNN1DIBl2cqftt5cqVPPLII3Tr1o2+ffvSrVs3evfuzaFDh/7xvlXn27p1Ky6Xi5YtWxIVFUXNmjVp3bo127dv59ixY8GzkZGRQXp6OlWrVuX8+fPY7XaqVKlCXFxccNEiJYNNuqSNGzcyceJEEhISGDhwIGFhYRec9QujatWqDB06FIDJkyezb9++4CLSFXC73SxYsIBdu3bx3nvvsXv3bnr27Mn8+fNZvHgx+EJKHZYuXUr//v0ZOHAggwYN0ob+/fvz1Vdf4XK5AsLw2LFjmM1mkpKSwPftkdKlS3Pu3DnS09O1cqpz586RmZnJyJEj6dq1K+3ataN///6kpaX945AtCBlsUr7URvfZZ59x+vRpXnzxRerXrx9crFDUgHzuuecYOHAg+/bt0z7bdjUbfShTFIUXXniBhQsX0qxZM86fP4/NZgMgPT39gpPSwYMHmTdvHosWLWLhwoXaMHfuXLZt24bX6w0o73Q6AdDr9do49R1tt9utjVOVKFGCOnXq0LJlSwYNGkSlSpWYNGkSEydORPh9/KPIicvwer1yKGaDaubMmcJgMIjmzZuL8+fPX7X2IIQQ+/fvF82bNxclSpQQKSkpsv39g0G1Zs0a8fDDD4saNWqIe++9VzRo0EAA4u2339bKqf+eOXNGbNu2TezYsSNg2LZtmzhy5IjweDwByx45cqQICwsTn332mRBCCIfDIfr27SsAsXjxYq2cyu12i5ycHO3v9evXi8TERFGnTh1tfPDrCH49/4TssUkB1DPoihUrePXVVylVqhQjRowgPj4+uGiRqlatGl27diUzM5MRI0bIS9J/KDc3l9dff51ly5YxZMgQli5dSq9evYKLafV8+PBhlixZwrJlywKGJUuWsHPnTu1dTFXlypWx2+3aA3uEEBw6dIiSJUuSmJgIgMfjAd/DfTZs2MDWrVtxOBwAlCxZkri4OJxO5wW9xyIVnHTBglNUDqE9CN9ZvGnTpgIQn3766TVpC0IIkZeXJzp37iwA8eqrr2rjg8vKIf9BCCFOnToloqOjRbVq1cT69evFgQMHxEMPPSQAMXLkSK0uVZ9++qmIi4sTSUlJAUNsbKzo3bu3sNlsQvj18A4dOiTi4+NFnTp1xN9//y2WLVsmANGlSxdhs9nE5s2bxaOPPiq++OILkZWVJV599VWhKIr45JNPRHp6uvjwww+FoijizTff1JYZ/Dr8X88/JYNNDtqgeueddwQgmjRpIs6dO3fN2oEQQmzcuFFUqlRJlClTRmzevPmarTsUBiGEsNls4tlnnxWAiI2NFY0aNRJNmjQRgHjxxReF2+3W6lkIIQ4ePCgWLlwoFi9eHDAsWLBAbNu2TSuvLl8IId577z2h0+lEQkKCiIyMFKVLlxZLliwRQggxffp0LejsdrvYsmWLqFSpklAURVSsWFEAomnTpuLYsWPaci82FIb8HJukURSFbdu2cd9992E0Gpk7dy6NGze+Zm1AveSZPXs2jz32GM8//zwTJkwA2Q4LTFEUzpw5w/fff8+xY8do2bIlNWvWZPny5VSuXJl7770Xg8EQ8FmzSwne74rv113mz5/Ptm3bMJlMtGvXTvsWwYEDB/jll1+oXbs2zZs3x2g0snv3bhYuXEhGRgZJSUl06tSJ5OTkfJfv73Lbdiky2CTwNaJTp07x2GOPsXr1aiZPnkyfPn3gGrcBRVFwuVwMGjSIr776iv/+978888wzcI2342Z2qUAoin14seV7vd4LvvN7sXc+C7Id+c1XUDLYJK0BjRs3jldeeYX777+f77///h9/yb2w1F5H27ZtOXfuHLt27cr3U/PSxal1ejX32ZWswz+kClKeQgabfFe0mFMbz6JFixg1ahQGg4FBgwYRHR0dXPSaKlOmDN27d+fs2bO8++672Gy2QjX04kb87/558OgidSXrUMsWtHxhyWCTAJgxYwbnzp3jtddeo127dnAFZ9aipq73+eefp1OnTkycOJFFixYFF5Oki5LBVoypPaBNmzaxfPlyHnjgAd5++224jqGmEkIQExPDO++8g8lkYtGiRRd8pkqSLkYGWzG3fv16unXrhsPh4I033gh4x+xGULduXfr3709KSgrTpk2DQt57kYoHGWzFlKIoZGVl8c4773D06FEGDRpE06ZNg4tdV2rA9unTh4oVKzJ8+HA2b94cXEySLiCDrRhSezxTpkxhyZIlNGzYkOeffx5ugEvQYEIIqlevzltvvcXp06d588035SWpdFny4x7FkOL7ae769euj0+mYPXs2TZo0uWHrWg2x119/nTFjxjB9+nS6d+9+w26vVDQKc/KSPbZiRvH9vPOkSZM4deoUvXr10j41fqNSA2zw4MHUqVOHzz//nMOHDxeq4UuhTQZbMaIGwbRp0xgzZgwtWrTgiSeegJukZ16yZEl69OjB+vXrGTZsGBaLRYablC8ZbMXMgQMHGD16NLm5uQwbNkz7zt6NTg3exx57jLvuuovvv/+eKVOmQCEvWaTQJIOtmFAvQadOncrff/9N9+7dad26NdwkvTV825mUlMT7779PiRIlGDNmDCdOnAguJkky2IoDtUczf/58Jk+eTIsWLfj444/R6/U3Taj5a9OmDW+//TaZmZn8+OOPIHttUhD5rmgxoCgKhw4d4pFHHmHnzp1Mnz6dnj173rR1q/gexNu6dWv27t3L9OnT6dSpE8j2GlIKc7KSPbYQpzaOzz77jJ07d9KpUyc6d+4cXOymEx4ezogRI7DZbAwYMID9+/cHF5GKMRlsxcCSJUv4+uuvSUpK4s033yzUU9xvBOq2t23blueff55jx44xY8YMKORZXgod8lI0hCmKQlpaGt26dWPFihXMmDGDHj16QIjUq6IonDhxgs6dO3PkyBH++OMPateuHRKvTSrcSUr22EKUoijk5OTw5ptvsmLFCp588km6du0KIRJq+F5H+fLlGTNmDOHh4QwbNoz09PRCHRBSaJDBFoLUAzslJYUvvviCSpUq8fLLL2M0GkMm1Py1aNGC5557joULFzJkyBCcTqcMt2JOBluIOnr0qPYB1j59+nDHHXcEFwkJalAPGjSI5s2bM336dH766Sco5KWMdHOTwRZi1IN52rRpbN26lUaNGhWLh6HEx8fz+uuvExsby/vvv8+RI0eCi0jFSJG9eSDPjjeO9evX89xzz3HmzBlSUlKu+099XwuK75sV7733HsOHD+fFF1/k448/xmw2BxeVrrOCtsPCZEqRBFthNqCoOBwOjEbjBY//CiVerxeXy4VOp0Ov1+P1enG73QC43W7M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MtgkSQo5MtgkSQo5MtgkSQo5MtgkSQo5MtgkSQo5MtgkSQo5MtgkSQo5MtgkSQo5MtgkSQo5MtikIqcoijZI0vWgCCFE8Eh/l5ksSeALs4KQ7enmF1zXBanTopjnSshgkwpFbXwul4s9e/awb98+Dh06hMvlIioqirCwMGJjY7njjjuoXbu2Np9sVzcfta7//vtv1q5di8PhoHHjxtSvXx8uUaeKopCXl8fWrVsBuP322ylRosRFy6tksEnXnNro3G43M2fOJCUlhf3793P27FmsVmtwcSpVqkS3bt3o3r07tWrVQq/Xg2xfV0V+gVDY/awuc/369QwYMIAtW7YAUKVKFT766CO6dOkC+axHnW/MmDGMHDmSChUq8MUXX9C4ceMLygbL73UUlAw26YqpDS41NZWRI0cybdo03G43cXFxNG/enLp162KxWMjLy+P48eMcOHCAkydPYrPZSEpKonv37rz88sskJSWBbGNFSq2bkydPkpubS1hYGGXKlCEsLKxQ+1lRFNxuNw8//DC//fYbU6dOpVSpUjz55JPccsstzJ07l6SkpAvWoSgK27dv59FHH+Xw4cOULVuW2bNn06xZswvKBitMsCEuw+v1ykEO2qBat26duPPOOwUgbrnlFjF06FCxbt06kZeXJ4QQwu12C5fLJWw2mzhz5oyYP3++6NSpkwAEIO655x7x448/CqfTKdtZEQ1CCJGdnS0+/PBDUbVqVQGIkiVLiv79+4sDBw5csJ8Lwr/szp07Rfny5UXTpk216S+++KKIiYkRc+fODSivzuPxeESvXr1EjRo1RN26dcUtt9wi/vjjjwvK5jcUhnxXVCow9Qy6cOFCevbsydatW7nnnntYsGABo0aN4u677yYiIgIAvV6PwWAgLCyM0qVL07FjR1JSUvjqq6+oVasWa9as4fHHH+ff//43Vqu1cGdnSdt/CxYsYOjQocTFxTF27FjatWvHxIkTGT9+PF6vVyunKArHjh3jm2++Ydq0aUyfPl0bpk6dys8//4zFYgmolyNHjmCxWALuld56663k5ORw4MABbRxBbWX58uW8+eabVK1aFafTedmeWpEITrpgwSkqh+I5qGbNmiUqVKggANG7d29x+PDhArcV1f79+8VLL70k9Hq9AET//v2F1Wot8HLkkP8ghBDbtm0TU6ZMEevXrxder1fMmDFDAKJz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)

Εικόνα 1. Το σχήμα της ισοδύναμης συνάρτησης στάθμισης για διαφορετικές τιμές του a (Burt & Adelson, 1983)

--------------------------------------------------------------------------------

β) Ερώτηση: Τι ορίζουμε ως εντροπία; Υπολογίστε την μέγιστη τιμή εντροπίας που μπορεί να έχει μια grayscale εικόνα.

Απάντηση: Ως εντροπία ορίζουμε τον ελάχιστο αριθμό bits ανά pixel που απαιτείται για να κωδικοποιήσουμε πλήρως μια εικόνα. Εκφράζει πρακτικά την ποσότητα της πληροφορίας που περιέχεται σε μια εικόνα και υπολογίζεται από την κατανομή των εντάσεων των pixel. Η μαθηματική έκφραση της είναι:

$$ H = -\sum_{i=0}^{L-1} f(i) \log_2(f(i)) $$

όπου:
- H είναι η εντροπία
- f(i) είναι η πιθανότητα εμφάνισης της έντασης i στην εικόνα
- L είναι το πλήθος των πιθανών τιμών έντασης (για grayscale εικόνες L=256)

Η εντροπία φτάνει στην μέγιστη τιμή της όταν όλες οι πιθανότητες f(i) είναι ίσες, δηλαδή όταν όλες οι τιμές έντασης εμφανίζονται με την ίδια συχνότητα. Σε μια grayscale εικόνα οι τιμές έντασης κυμαίνονται από 0 έως 255 και δεδομένου ότι είναι ομοιόμορφα κατανεμημένη η πιθανότητα εμφάνησης κάποιας από τις εντάσεις αυτές, η μέγιστη εντροπία είναι 8.

$$ f(i) = \frac{1}{256}, \forall i = 0, 1, ..., 255 $$
$$ H_{max} = - \sum_{i=0}^{255} (\frac{1}{256}) \log_2(\frac{1}{256}) $$

Και άρα, $$ H_{max} = -256 (\frac{1}{256}) (-8) = 8 \, bits/pixel $$

Η μεγαλύτερη μείωση στο μέγεθος της εικόνας επιτυγχάνεται όταν η παράμετρος a ισούται με 0.6. Στην πράξη συνήθως χρησιμοποιούμε την τιμή 3/8 για την παράμετρο a, η οποία αδηγεί σε διωνυμικό πυρήνα που προσεγγίζει την gaussian κατανομή.

--------------------------------------------------------------------------------

γ) Ερώτηση: Πώς η επιλογή του μεγέθους του bin επηράζει το αποτέλεσμα κβαντισμού;

Απάντηση: Η επιλογή του μεγέθους του bin επηρεάζει άμεσα την ακρίβεια και την ποιότητα του αποτελέσματος του κβαντισμού. Με την διαδικασία του κβαντισμού αντιστοιχίζεται ένας υψηλής ανάλυσης χώρος τιμών σε ένα πεπερασμένο σύνολο διακριτών τιμών. Όσο μεγαλύτερο είναι το μέγεθος του bin, τόσο λιγότερα είναι τα επίπεδα στάθμης, το οποίο συνεπάγεται μεγαλύτερη απώλεια πληροφορίας. Με μεγάλο bin size οι τιμές 'στρογγυλοποιούνται' σε λιγότερες διακριτές στάθμες μειώνοντας έτσι το μέγεθος των δεδομένων. Στον κβαντισμό, επομένως, είναι σημαντικό να παρθεί υπόψιν το μέγεθος του bin προκειμένου να μην υπάρξει σημαντική αλλοίωση της πληροφορίας της εικόνας για το ανθρώπινο μάτι. Συνήθως το bin size ελαττώνεται όσο προχωράμε στα υψηλότερα επίπεδα.

--------------------------------------------------------------------------------

δ) Εξηγήστε πώς επηρεάζεται η κβάντιση από το πλήθος των επιπέδων της πυραμίδας;

Απάντηση: Η κβάντιση επηρεάζεται άμεσα από το πήθος των επιπέδων μιας πυραμίδας καθώς κάθε επίπεδο αντιπροσωπεύει διαφορετική χωρική ανάλυση και φασματική πληροφορία της αρχικής εικόνας. Τα χαμηλού επιπέδου pixel (αυτά που βρίσκονται πιο κοντά στην βάση της πυραμίδας), έχουν υψηλότερη πυκνότητα δειγμάτων αφού επεικονίζουν το σύνολο της πληροφορίας της αρχικής εικόνας και άρα απαιτούν λιγότερα επίπεδα κβαντισμού για να προσεγγιστούν οι τιμές τους με αποδεκτό σφάλμα. Αντιθέτως, τα υψηλού επιπέδου pixel αναπαριστούν με λιγότερη λεπτομέρεια την αρχική εικόνα, με αποτέλεσμα να απαιτούν περισσότερα επίπεδα κβάντισης για να διατηρηθούν τα σημαντικά χαρακτηριστικά χωρίς επιπλέον αισθητή αλλοίωση.

# Εργαστηριακό Μέρος
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import cv2
import urllib.request
import skimage
import scipy.stats as st

from matplotlib import pyplot as plt
from skimage import data
# %matplotlib inline

"""Ζητάμε τις εικόνες Lena και camera"""

HTTP_response = urllib.request.urlopen('http://www.image.ntua.gr/~tpar/LABimage/lena.png')

arr = np.asarray(bytearray(HTTP_response.read()), dtype=np.uint8)
BGR = cv2.imdecode(arr,-1) # BGR (Blue Green Red) is the OpenCV default

camera = skimage.data.camera() # camera (512, 512) uint8 ndarray

"""Ορίζουμε τις συναρτήσεις που θα χρησιμοποιήσουμε:"""

def GKernel(a):
  b = 1/4
  c = 1/4 - a/2
  h = np.array([c, b, a, b, c]) # 1D kernel

  return np.outer(h, h) # Same as h*h.reshape(-1, 1) to take the 5x5 kernel

''' Gaussian reduction on an input image I by first applying a low-pass filter
and then downsampling the filtered image. '''

def GREDUCE(I, h):
  # depth == -1 so that the original image and the filtered one have the same depth (type)
  LP_filtered_I = cv2.filter2D(I, -1, h) # Convolution to the input image I using kernel h
  reduced_downsampled_I = LP_filtered_I[::2, ::2] # Keep every second pixel along both rows and columns
  # or reduced_downsampled_I = cv2.pyrDown(I)

  return reduced_downsampled_I

''' Build a Gaussian Pyramid by repeatedly applying LPF and downsampling the image. '''

def GPyramid(I, a, depth): # depth: the number of levels ot the pyramid
  gaussian_pyramid = [] # list to store the images at each level
  gaussian_pyramid.append(I) # The lowest level is the original image

  kernel = GKernel(a)
  for i in range (0, depth-1):
    gaussian_I = GREDUCE(gaussian_pyramid[i], kernel)
    gaussian_pyramid.append(gaussian_I)

  return gaussian_pyramid

def GEXPAND(I, h):
  if len(I.shape) == 2: # Grayscale image
    upsampled_I = np.zeros((I.shape[0]*2, I.shape[1]*2), dtype=np.float64)
    upsampled_I[::2, ::2] = I
  else: # Colored image
    upsampled_I = np.zeros((I.shape[0]*2, I.shape[1]*2, I.shape[2]), dtype=np.float64)
    upsampled_I[::2, ::2, :] = I

  expanded_I = 4 * cv2.filter2D(upsampled_I, -1, h) # page 534, function (2)

  # -------- If we want to work with cv2.pyrUp() --------
  # upsampled_I = cv2.pyrUp(I) # Interpolation with L=2
  # expanded_I = cv2.filter2D(upsampled_I, -1, h)
  # -----------------------------------------------------

  return expanded_I

def LPyramid(I, a, depth):
  kernel = GKernel(a)
  gaussian_pyramid = GPyramid(I, a, depth)

  laplacian_pyramid = [] # list to store Laplacian pyramid
  for i in range (0, depth - 1):
    upsampled_gaussian_I = GEXPAND(gaussian_pyramid[i+1], kernel)
    difference = gaussian_pyramid[i] - upsampled_gaussian_I + 128 # +128 in order to keep pixel between (0, 255)
    laplacian_pyramid.append(difference)

  laplacian_pyramid.append(gaussian_pyramid[depth-1]) # The upper level of laplacian is the last image in gaussian pyramid

  return laplacian_pyramid

def L_Pyramid_Decode(L, a):
  kernel = GKernel(a)

  gN = L[len(L)-1]
  for i in reversed(range(len(L)-1)):
    expanded = GEXPAND(gN, kernel)
    gN = L[i] + expanded - 128

  return gN

def L_Quantization(laplacian_I, bins):
  n = 256 / bins
  indices = np.digitize(laplacian_I, np.arange(0, 256, n)) - 1
  C = indices * n

  return C.astype(np.uint8)
  #C.astype(np.float64)

# def L_Quantization(L,bins):                                                       # Παράμετροι εισόδου είναι η εικόνα που θα κβαντιστεί και ο αριθμός των bins
#     if (len(L.shape)==2):                                                         # Grayscale εικόνα
#         C=np.zeros((L.shape[0], L.shape[1]), dtype=np.float64)
#         max_val=L.max()
#         n=256/bins                                                                # Μέγιστη τιμή είναι το 255, υπολογισμός bin size για n bins
#         for i in range (0,L.shape[0]):                                            # Για κάθε pixel
#             for j in range(0,L.shape[1]):
#                 for m in range(0,bins):
#                     if (L[i][j]<=(m+1/2)*n and L[i][j]>=(m-1/2)*n):               # Εξίσωση (5) της πηγής
#                         C[i][j]=m*n
#                         break
#     else:                                                                         # Εικόνα με χρώμα
#         C=np.zeros((L.shape[0], L.shape[1],L.shape[2]), dtype=np.float64)
#         max_val=L.max()
#         n=255/bins                                                                # Μέγιστη τιμή είναι το 255, υπολογίζουμε το bin size για n bins
#         for i in range (0,L.shape[0]):                                            # Για κάθε pixel
#             for j in range(0,L.shape[1]):
#                 for k in range(0,L.shape[2]):
#                     for m in range(0,bins):
#                         if (L[i][j][k]<=(m+1/2)*n and L[i][j][k]>=(m-1/2)*n):     # Εξίσωση (5) της πηγής
#                             C[i][j][k]=m*n
#                             break
#     return C

"""**Δοκιμές Αλγορίθμου:**

Θα μετατρέψουμε αρχικά την φωτογραφία 'lena' σε RGB και Grayscale προκειμένου να ελέγξουμε τον αλγόριθμο τόσο για έχρωμες όσο και για άχρωμες εικόνες. Ως γνωστόν, οι grayscale εικόνες έχουν ένα μόνο χρωματικό κανάλι και όχι τρία.
"""

RGB_lena = cv2.cvtColor(BGR, cv2.COLOR_BGR2RGB) # RGB
gray_lena = cv2.cvtColor(BGR, cv2.COLOR_BGR2GRAY) #Grayscale

plt.figure(figsize=(10, 5))

# RGB Image
plt.subplot(1, 2, 1)
plt.imshow(RGB_lena)
plt.title("Lena in RGB")
plt.axis('off')

# Grayscale Image
plt.subplot(1, 2, 2)
plt.imshow(gray_lena, cmap='gray') # cmap='gray' ensures the pixel values are treated as brightness levels
plt.title("Lena in Grayscale")
plt.axis('off')

"""Η 'lena' σε grayscale θα μπορούσε να φορτωθεί και με τον ακόλουθο τρόπο:"""

Y = cv2.cvtColor(BGR, cv2.COLOR_BGR2YCrCb)[:,:,0]
plt.figure(figsize=(4, 4))
plt.imshow(Y, cmap='gray')

"""Έχουμε ήδη φορτώσει την εικόνα 'camera' με την βοήθεια της βιβλιοθήκης skimage."""

plt.figure(figsize=(4, 4))
plt.imshow(camera, cmap="gray")
plt.title('Camera in grayscale')

"""Θα κατασκευάσουε ακόμα μια βοηθητική συνάρτηση με την οποία θα αναπαριστούμε τις πυραμίδες."""

def helperPyramid(pyramid, im_type='gray'):
  if im_type not in ['gray', 'color']:
        raise ValueError("Invalid image type. Use 'gray' for grayscale or 'color' for RGB images.")

  plt.figure(figsize=(4 * len(pyramid), 4))

  for i, level in enumerate(pyramid):
        plt.subplot(1, len(pyramid), i + 1)

        if im_type == 'gray':
            plt.imshow(level, cmap='gray')
        else: # For RGB images
            plt.imshow(level.astype(np.uint8))

        plt.title(f'Level {i}', fontsize=14)
        plt.axis('off')

  plt.tight_layout()
  plt.show()

# Computation of Gaussian Pyramid for Lena (RGB and Grayscale) and for camera

# Lena in RGB
RGB_lena_gauss = GPyramid(RGB_lena, 0.6, 5)
helperPyramid(RGB_lena_gauss, 'color')

# Lena in Grayscale
gray_lena_gauss = GPyramid(gray_lena, 0.6, 5)
helperPyramid(gray_lena_gauss, 'gray')

# Camera
camera_gauss = GPyramid(camera, 0.6, 5)
helperPyramid(camera_gauss,'gray')

"""**Σχολιασμός:** Αυτό που παρατηρούμε είναι ότι όσο ανεβαίνουμε επίπεδο, τόσο πιο θολή και ομαλοποιημένη γίνεται η εικόνα μας. Αυτό είναι αναμενόμενο διότι η συνάρτηση GPyramid() πραγματοποιεί συνέλιξη της εικόνας με τον πυρήνα που κατασκευάζεται μέσω της GKernel() - εξομάλυνση - και, ύστερα, η εικόνα που προκύπτει υποδειγματοληπτείται με ρυθμό M=2. Κάθε νέα επίπεδο, δηλαδή, περιέχει τους μισούς αριθμούς pixel.

*Σημείωση: Αυτό που παρατήρησα ήταν ότι αν αντικαταστήσω το χειροκίνητο decimation με M=2, και χρησιμοποιήσω την εντολή cv2.pyrDown(), θα παίρναμε παρόμοια αποτελέσματα, μόνο που το θόλωμα θα ήταν περισσότερο ομαλό και ομοιόμορφο και παρατηρούταν ήδη από χαμηλότερο level πυραμίδας.*

1. Ζητείται να ελέγξουμε τις υλοποιήσεις των παραπάνω συναρτήσεων χρησιμοποιώντας τις εικόνες 'Lena' και 'camera'.
"""

# Computation of Laplacian Pyramid for Lena (RGB and Grayscale) and for camera

# Lena in RGB
RGB_lena_lapl = LPyramid(RGB_lena, 3/8, 5)
helperPyramid(RGB_lena_lapl, 'color')

# Lena in Grayscale
gray_lena_lapl = LPyramid(gray_lena, 3/8, 5)
helperPyramid(gray_lena_lapl, 'gray')

# Camera
camera_lapl = LPyramid(camera, 3/8, 5)
helperPyramid(camera_lapl,'gray')

"""**Σχολιασμός:** Αυτό που παρατηρούμε είναι ότι όσο ανεβαίνουμε επίπεδο, τόσο πιο ευδιάκριτα γίνονται τα χαρακτηριστικά της εικόνας, τόσο εντονότερα φαίνονται οι λεπτομέρειες που απεικονίζονται. Αυτό είναι αναμενόμενο διότι όσο προχωράμε επίπεδο τόσο πιο διακριτές είναι οι λεπτομέρειες που χάνονται στα επίπεδα της Gaussian Pyramid. Άλλωστε η Laplacian Pyramid σε κάθε επίπεδο αποτελείται από την διαφορά μεταξύ δυο διαδοχικών επιπέδων της Gaussian Pyramid και συγκεκριμένα η διαφορά μεταξύ του ίδιου επιπέδου στην GP μείον της interpolated image του επόμενου επιπέδου στην GP.
$$ L_i = g_i - GEXPAND(g_{i+1}) $$
με $ L_N =g_N $ την μικρότερη gaussian image.

Επομένως, κάθε επίπεδο στην Λαπλασιανή πυραμίδα αποθηκεύει την λεπτομέρεια που χάνεται ανά επίπεδο καθώς κατασκευάζεται η Γκαουσιανή πυραμίδα, κρατά, δηλαδή, μόνο τις λεπτομέρειες και τις υψηλές συχνότητες που κάθηκαν κατά την μετάβαση στην επόμενη Γκαουσιανή εικόνα. Συγκεκριμένα, το χαμηλότερο επίπεδο (αυτό με το μεγαλύτερο μέγεθος εικόνας) αποθηκεύει την πληροφορία με το υψηλό συχνοτικό περιεχόμενο, ενώ όσο προχωράμε σε επίπεδο, τόσο πιο ζωνοπερατό γίνεται το περιεχόμενο που διατηρείται, με την τελευταία εικόνα του μεγαλύτερου επιπέδου να κρατάει το χαμηλό συχνοτικό περεχόμενο (αυτή αναγαστικά ισούται με την τελευταία Gaussian, αφού δεν υπάρχει άλλη να αφαιρεθεί).

*Σημείωση: Η υλοποίηση θα μπορούσε να πραγματοποιηθεί και με την έτοιμη συνάρτηση cv2.pyrDown(). Το αποτέλεσμα θα ήταν παρόμοιο, με την περίπτωση αυτή να δημιουργεί πιο ομοιόμορφη εικόνα σε κάθε επίπεδο.*
"""

def normalize(image):
    return (np.uint8)(255 * (image - np.min(image)) / (np.max(image) - np.min(image)))

def showFrequencyContent(pyramid):
    num_levels = len(pyramid)
    fig, axs = plt.subplots(1, num_levels, figsize=(20, 5))

    for i in range(num_levels):
        laplacian_level = pyramid[i]

        # 2D Fourier (FFT)
        f_transform = np.fft.fft2(laplacian_level)
        f_shift = np.fft.fftshift(f_transform)

        # Magnitude Spectrum
        magnitude_spectrum = np.log(np.abs(f_shift) + 1)

        magnitude_spectrum = normalize(magnitude_spectrum)

        axs[i].imshow(magnitude_spectrum, cmap='gray')
        axs[i].set_title(f'Level {i} Frequency Content')
        axs[i].axis('off')

    plt.suptitle('Frequency Content of Laplacian Pyramid')
    plt.show()

showFrequencyContent(RGB_lena_lapl)
showFrequencyContent(gray_lena_lapl)
showFrequencyContent(camera_lapl)

"""**Σχολιασμός:** Όπως μπορούμε να παρατηρήσουμε εφαρμόζοντας 2D Fourier Transform, στα χαμηλά επίπεδα της πυραμίδας (Level 0, 1) διατηρούνται οι λεπτές υφές και το υψηλότερο συχνοτικό περιεχόμενο. Όσο ανεβαίνουμε σε επίπεδο (Level 4) τόσο περισσότερο επικρατούν οι χαμηλές συχνότητες και οι γενικές δομές (θαμπή εικόνα, σμίκρυνση και απώλεια λεπτομέρειας).

*Οι έντονες κάθετες και οριζόντιες γραμμές στο κέντρο υποδεικνύουν ότι οι χαμηλές συχνότητες κυριαρχούν κοντά στο μηδενικό σημείο.*

Στην συνέχεια θα εξετάσουμε την διαδικασία ανακατασκευής της εικόνας από την Laplacian Pyramid κάνοντας χρήση της συνάρτησης L_Pyramid_Decode().
"""

def helperPlot(original, reconstructed, title, isRGB=False):
  plt.figure(figsize=(6, 6))

  plt.subplot(1, 2, 1) # Display reconstructed image
  if isRGB:
    plt.imshow(reconstructed.astype(np.uint8))
  else:
    plt.imshow(reconstructed, cmap="gray")

  plt.title('Reconstructed', fontsize=10)
  plt.axis('off')

  plt.subplot(1, 2, 2) # Display Original Image
  if isRGB:
    plt.imshow(original.astype(np.uint8))
  else:
    plt.imshow(original, cmap="gray")

  plt.title('Original', fontsize=10)
  plt.axis('off')

# Lena in RGB
RGB_lena_dec = L_Pyramid_Decode(RGB_lena_lapl, 3/8)
helperPlot(RGB_lena, RGB_lena_dec, 'Lena in RGB', True)
print('Reconstruction of Lena in RGB successful:', (RGB_lena==RGB_lena_dec).all())

# Lena in Grayscale
gray_lena_dec = L_Pyramid_Decode(gray_lena_lapl, 3/8)
helperPlot(gray_lena, gray_lena_dec, 'Lena in Grayscale')
print('Reconstruction of Lena in Grayscale successful:', (gray_lena==gray_lena_dec).all())

# Camera
camera_dec = L_Pyramid_Decode(camera_lapl, 3/8)
helperPlot(camera, camera_dec, 'Camera in Grayscale')
print('Reconstruction of camera in Grayscale successful:', (camera==camera_dec).all())

"""**Σχολιασμός:** Παρατηρούμε ότι η ανακατασκευασμένη εικόνα με την αρχική (original) είναι πανομοιότυπες. Αυτό σημαίνει ότι η διαδικασία ανακατασκευής μέσω της κωδικοποίησης ήταν επιτυχής, δεδομένου ότι η διαδικασία γίνεται με την ίδια τιμή για την παράμετρο a του πυρήνα με αυτή που είχε χρησιμοποιηθεί για την κατασκευή της Λαπλασιανής πυραμίδας.

2. Στην συνέχεια ζητείται να εμφανίσουμε την αρχική και την αποκωδικοποιημένη εικόνα χρησιμοποιώντας διαφορετικές τιμές για την παράμετρο a του πυρήνα.
"""

def helperLoopOfa(image_name, original, a, depth=5, im_type='grayscale', isRGB=False):
    for i in a:
        laplacian = LPyramid(original, i, depth)
        decoded = L_Pyramid_Decode(laplacian, i)

        # Plot the pyramid levels for the current value of alpha
        if len(original.shape) == 2:  # Grayscale image
            f, ax = plt.subplots(1, len(laplacian) + 1, figsize=(20, 20))
            for j in range(len(laplacian)):
                ax[j].imshow(laplacian[j], cmap="gray")
                ax[j].set_title(f'Level {j} (α = {i:.1f})', fontsize=10)
            ax[len(laplacian)].imshow(original, cmap="gray")
            ax[len(laplacian)].set_title(f'Original image', fontsize=10)
        else:  # RGB image
            f, ax = plt.subplots(1, len(laplacian) + 1, figsize=(20, 20))
            for j in range(len(laplacian)):
                ax[j].imshow(laplacian[j].astype(np.uint8))
                ax[j].set_title(f'Level {j} (α = {i:.1f})', fontsize=10)
            ax[len(laplacian)].imshow(original)
            ax[len(laplacian)].set_title(f'Original image', fontsize=10)

        plt.show() # Display Laplacian pyramid and original image

        # Plot the original and decoded images
        # f, (ax0, ax1) = plt.subplots(1, 2, figsize=(12, 6))
        # ax0.imshow(original, cmap="gray" if im_type == 'grayscale' else None)
        # ax0.set_title(f'Original {im_type.capitalize()}', fontsize=10)
        # ax1.imshow(decoded, cmap="gray" if im_type == 'grayscale' else None)
        # ax1.set_title(f'Decoded (α={i:.1f})', fontsize=10)
        # plt.show()

        # Check if the reconstruction was successful
        success = np.allclose(original, decoded, atol=1e-5)  # Check reconstruction accuracy
        print(f'Reconstruction of {image_name} successful: {success}')

        import time
        time.sleep(2)

images = {'LenaRGB': [RGB_lena, 'RGB', True],
          'LenaGrayscale': [gray_lena, 'grayscale', False],
          'Camera': [camera, 'grayscale', False]
}

# Ckeck for different values of a
for image_name, ((original, im_type, isRGB)) in images.items():
  helperLoopOfa(image_name, original, a=np.arange(0.3, 0.8, 0.1), depth=5, im_type=im_type, isRGB=isRGB)

"""**Σχολιασμός:** Όπως μπορούμε εύκολα να παρατηρήσουμε, οι διαφορετικές τιμές για το a δεν επηρεάζουν την τελική ανακατασκευασμένη εικόνα, αφού με την ίδια παράμετρο a γίνεται τόσο η υλοποίηση της Λαπλασιανής πυραμίδας όσο και η ανακατασκευή της αρχικής εικόνας. Το a είναι αυτό που καθορίζει την κατανομή του Gaussian φίλτρου και άρα την ποσότητα εξομάλυνσης που θα εφαρμοστεί στην εικόνα. Αυτό που αλλάζει, λοιπόν, με την αλλαγή του a είναι η ποιότητα της εικόνας κάθε επιπέδου της πυραμίδας. Συγκεκριμένα, όσο μεγαλύτερο είναι το a τόσο πιο θολή είναι η εικόνα συγκρίνοντας κάθε αντίστοιχο επίπεδο με διαφορετική τιμή a. Αυτό γιατί λόγω μεγαλύτερης τιμής a, η κατανομή  του generating kernel στενεύει, συμπιέζεται τριγύρω από την κεντρική τιμή, με αποτέλεσμα το κεντρικό pixel να επηρεάζει περισσότερο σε σχέση με τα γειτονικά του. Αυτό δημιουργεί ανομοιομορφία και μεγαλύτερες εντάσεις στις αλλαγές, κάτι που γίνεται αισθητό στην μετάβαση από την τιμή a=0.5 στην a=0.6.

3. Στην συνέχεια ζητείται να εμφανίσουμε την αρχική και την αποκωδικοποιημένη εικόνα χρησιμοποιώντας διαφορετικές τιμές για το πλήθως των επιπέδων της πυραμίδας.
"""

def helperLoopOfDepth(image_name, original, depth, a=3/8, im_type='grayscale', isRGB=False):
    for i in depth:
      laplacian = LPyramid(original, a, i)
      decoded = L_Pyramid_Decode(laplacian, a)

      # Plot the pyramid levels for the current value of alpha
      if len(original.shape) == 2:  # Grayscale image
          f, ax = plt.subplots(1, len(laplacian) + 1, figsize=(20, 20))
          for j in range(len(laplacian)):
              ax[j].imshow(laplacian[j], cmap="gray")
              ax[j].set_title(f'Level {j}', fontsize=10)
          ax[len(laplacian)].imshow(original, cmap="gray")
          ax[len(laplacian)].set_title(f'Original image', fontsize=10)
      else:  # RGB image
          f, ax = plt.subplots(1, len(laplacian) + 1, figsize=(20, 20))
          for j in range(len(laplacian)):
              ax[j].imshow(laplacian[j].astype(int))
              ax[j].set_title(f'Level {j}', fontsize=10)
          ax[len(laplacian)].imshow(original)
          ax[len(laplacian)].set_title(f'Original image', fontsize=10)

      plt.show() # Display Laplacian pyramid and original image

      # Ensure decoded image values are within valid range [0, 255] for RGB
      if isRGB:
          decoded = np.clip(decoded, 0, 255).astype(np.uint8)

      # Plot the original and decoded images
      # f, (ax0, ax1) = plt.subplots(1, 2, figsize=(12, 6))
      # ax0.imshow(original, cmap="gray" if im_type == 'grayscale' else None)
      # ax0.set_title(f'Original {im_type.capitalize()}', fontsize=10)
      # ax1.imshow(decoded, cmap="gray" if im_type == 'grayscale' else None)
      # ax1.set_title(f'Decoded (depth={i})', fontsize=10)
      # plt.show()

      # Check if the reconstruction was successful
      success = np.allclose(original, decoded, atol=1e-5)  # Check reconstruction accuracy
      print(f'Reconstruction of {image_name} successful: {success}')

      import time
      time.sleep(2)
    return

images = {'LenaRGB': [RGB_lena, 'RGB', True],
          'LenaGrayscale': [gray_lena, 'grayscale', False],
          'Camera': [camera, 'grayscale', False]
}

# Ckeck for different values of depth
for image_name, ((original, im_type, isRGB)) in images.items():
  helperLoopOfDepth(image_name, original, depth=np.arange(3, 7, 1), a=0.5, im_type=im_type, isRGB=isRGB)

"""**Σχολιασμός:** Το depth αναφέρεται στον αριθμό των επιπέδων της πυραμίδας που θα υπολογιστούν. Όσο μεγαλύτερο είναι το depth τόσα περισσότερα επίπεδα πυραμίδας θα υπολογιστούν με αποτέλεσμα να μειώνεται η ανάλυση της εικόνας σε κάθε επίπεδο. Αυξάνοντας τον αριθμό των επιπέδων της πυραμίδας η αρχική εικόνα χωρίζεται όλο και περισσότερο σε ζωνοπερατά τμήματα, αποσπώντας όλο και περισσότερη πληροφορία και λεπτομέρεια της αρχικής εικόνας. Αυτό μπορούμε να παρατηρήσουμε στις παραπάνω εικόνες, χωρίς, όμως, όπως βλέπουμε να δημιουργείται θέμα στην ανακτασκευασμένη εικόνα. Όσο περισσότερα επίπεδα χρησιμοποιούμε, τόσο λιγότερη πληροφορία δίνει το πρώτο επίπεδο κατά την ανακατασκευή της εικόνας, πράγμα που αλλάζει όσο προχωράμε σταδιακά προς τα χαμηλότερα επίπεδα που έχουν διατηρήσει περισσότερη λεπτομέρεια.

4. Ζητείται ο υπολογισμός της εντροπίας και ταυτόχρονα η παρουσίαση των αντίστοιχων διαγραμμάτων για διαφορετικές τιμές στην παράμετρο a και depth για κάθε εικόνα.

Το ιστόγραμμα μας βοηθάει να αναγνωρίσουμε συγκεκριμένα features σε εικόνες. Συγκεκριμένα, σε αυτό απεικονίζεται η συχνότητα εμφάνισης των διακριτών grayscale τιμών μέσα σε μια εικόνα. Αυτό μας παρέχει διακριτοποιημένη απεικόνιση του τι περίπου αναμένουμε να απεικονίζεται στην υπό εξέταση εικόνα, και μπορεί να χρησιμοποιηθεί σαν είσοδο σε ταξινομητές.
"""

# Show Histograms for different values for depth parameter
def ShowHistograms(I, a, depth):
  def is_range(x):
    return isinstance(x, range) or hasattr(x, '__iter__')

  if is_range(depth) and is_range(a):
    raise ValueError("Either 'a' or 'depth' must be a constant, not both ranges.")


  entropy_res = []

  if is_range(depth):
    print("Varying 'depth', fixed 'a' =", a)
    for d in depth:
      laplacian_pyr = LPyramid(I, a, d)
      entropy = plot_pyramid_histograms(laplacian_pyr, f'a={a}, depth={d}')
      entropy_res.append((a, d, entropy))

  elif is_range(a):
    print("Varying 'a', fixed 'depth' =", depth)
    for alpha in a:
      laplacian_pyr = LPyramid(I, alpha, depth)
      entropy = plot_pyramid_histograms(laplacian_pyr, f'a={alpha}, depth={depth}')
      entropy_res.append((alpha, depth, entropy))

  else:
    laplacian_pyr = LPyramid(I, a, depth)
    entropy = plot_pyramid_histograms(laplacian_pyr, f'a={a}, depth={depth}')
    entropy_res.append((a, depth, entropy))

  return entropy_res

def plot_pyramid_histograms(laplacian_pyr, title):
    num_levels = len(laplacian_pyr)
    plt.figure(figsize=(20, 6))

    entropyList = []

    # Calculate the histograms for each level of the Laplacian pyramid
    for level in range(num_levels):
      laplacian = laplacian_pyr[level]

      # Ensure valid image format for histogram calculation
      if laplacian.dtype != np.uint8:
        laplacian = np.clip(laplacian, 0, 255).astype(np.uint8)


      hist = cv2.calcHist([laplacian], [0], None, [256], [0, 256])

      hist_norm = hist / np.max(hist)
      entropy = -np.sum(hist_norm * np.log2(hist_norm + 1e-10))
      entropyList.append(entropy)

      plt.subplot(1, num_levels, level + 1)
      plt.plot(hist)
      plt.title(f'Level {level}\nEntropy: {entropy:.4f}')

    plt.suptitle(title)
    plt.show()
# NOT USED

# Function to calculate the histogram of each Laplacian's pyramid level
def calcSumHist(lapl_pyramid, depth):
  sum_hist = np.zeros([256, 1], np.float64)

  for level in range(0, depth-1):
    # cv2.calcHist(images, channels, mask, histSize, ranges, accumulate=False)
    # channels -> [0] for grayscale
    # mask -> None to take the full image
    # histSize -> [256] number of bins
    # ranges -> [0, 256] range of pixel values
    # Returns a 256x1 array
    hist = cv2.calcHist([np.float32(lapl_pyramid[level])], [0], None, [256], [0, 256])
    sum_hist += hist

  return sum_hist

# Function to calculate the Laplacian Pyramid and then the histogram
def calcHist(I, a, depth):
  lapl_pyramid = LPyramid(I, a, depth)
  sum_hist = calcSumHist(lapl_pyramid, depth)

  return sum_hist

# Function to show histograms for a range of 'a'
def HistForDifa(I, depth):
  totalHist = [] # List that stores the histograms for every value of 'a'

  entropyList = []
  varianceList = []

  for i in np.arange(0.2, 0.8, 0.1): # Loop through all values of 'a' [0.2, ..., 0.7]
    sum_hist = calcHist(I, i, depth)
    totalHist.append(sum_hist)

    # Calculate Entropy
    normalized_hist = sum_hist / sum_hist.sum()
    entropy = -np.sum(normalized_hist * np.log2(normalized_hist + 1e-10))
    entropyList.append(entropy)

    # Calculate Variance
    varianceList.append(np.var(sum_hist / np.max(sum_hist)))

  f, ax = plt.subplots(2, 3, figsize=(18, 7))

  for i in np.arange(0.1, 0.7, 0.1):
    num = (int)(i * 10)
    plt.subplot(2, 3, num)
    plt.plot(totalHist[num - 1]/np.max(totalHist[num - 1])) # Normalized
    plt.title(f"Entropy = {entropyList[num - 1]:.4f} (a = {i:.1f})", fontsize=14)

  plt.tight_layout()
  plt.show()

  return entropyList, varianceList

print("Histograms for Lena in RGB")
[entropy, variance] = HistForDifa(RGB_lena, 5)

print("Histograms for Lena in Grayscale")
[entropy, variance] = HistForDifa(gray_lena, 5)

print("Histograms for Camera")
[entropy, variance] = HistForDifa(camera, 5)

print("Histograms for Lena in RGB")
[entropy, variance] = HistForDifa(RGB_lena, 3)

print("Histograms for Lena in Grayscale")
[entropy, variance] = HistForDifa(gray_lena, 3)

print("Histograms for Camera")
[entropy, variance] = HistForDifa(camera, 3)

"""**Σχολιασμός:** Όπως παρατηρούμε, η εντροπία διαφέρει καθώς αλλάζει η τιμή του a. Συγκεκριμένα, καθώς το a αυξάνεται, η εντροπία μειώνεται. Αυτό είναι λογικό καθώς αυτή μας δείχνει τον ελάχιστο αριθμό από bits ανά pixel (φωτεινότητα) που χρειάζεται για την κωδικοποίηση μιας εικόνας. Η πιθανότητα εμφάνισης ενός επιπέδου φωτεινότητας στην εικόνα υπολογίζεται από το (συνολικό) κανονικοποιημένο ιστόγραμμα της εικόνας. Επομένως, για μεγαλύτερη τιμή a, η εντροπία είναι μικρότερη και άρα η εικόνα σε αυτή την περίπτωση περιέχει μικρότερο μέγεθος πληροφορίας.

Κάτι ακόμα που παρατηρούμε είναι ότι για μικρότερο depth η εντροπία αυξάνεται ελάχιστα (τρίτο δεκαδικό). Αυτό σημαίνει ότι το ύψος της πυραμίδας δεν επηρεάζει αισθητά την τιμή για την εντροπία, δηλαδή σχεδόν ο ίδιος ελάχιστος αριθμός από bits/pixel θα χρειαστεί για την κωδικοποίηση της εικόνας.

5. Ζητείται να εντοπίσουμε το βέλτιστο a ως προς την εντροπία σε κάθε επίπεδο της Laplacian πυραμίδας για κάθε εικόνα.

Αποδεικνύεται εύκολα ότι η εντροπία έχει μέγιστη τιμή όταν
$$P_k=Η_1(k)=\frac{1}{K}$$
το οποίο αντιπροσωπεύει ένα επίπεδο ιστόγραµµα.
Σε αυτή την περίπτωση και µε δεδοµένο ότι $K=2^B$

$$Ε(Ι)=-\sum_{k=0}^{K-1}\frac{1}{K}log_2(\frac{1}{K})=B$$

- Η εντροπία της εικόνας I αυξάνεται, όταν το ιστόγραµµα της εικόνας απλώνεται.
- H εντροπία της εικόνας I έχει ελάχιστη τιµή, όταν υπάρχει µια και µόνη τιµή φωτεινότητας.
"""

# Function that computes the entropy
def computeEntropy(I, depth, title):
  probs = np.linspace(0.2, 1.0, 17)

  entropy = []

  # Iterate through the values of 'a'
  for i in range(np.size(probs)):

    hist = calcHist(I, probs[i], depth)
    norm_hist = hist / hist.sum() # Normalize in order to take the probability Pk

    # Calculate Entropy
    entropy_value = -np.sum(norm_hist * np.log2(norm_hist + 1e-10))
    entropy.append(entropy_value)

    # entropy_value = st.entropy(norm_hist)[0]
    # entropy.append(entropy_value)

  # print(f"The entropy of LPyramid for a = {probs[i]:.1f}, depth = {depth} is : {entropy}")
  print(f"Optimal value for entropy: {min(entropy)} found for value a: {probs[entropy.index(min(entropy))]}")

  fig, ax = plt.subplots(figsize=(8, 4))

  # Plot Entropy
  ax.plot(probs, entropy, marker='.')
  ax.set_title(f'Entropy of Image {title}')
  ax.set_xlabel('a')
  ax.set_ylabel('Entropy')

  plt.tight_layout()
  plt.show()

  return entropy

_ = computeEntropy(RGB_lena, 5, "Lena in RGB")
_ = computeEntropy(gray_lena, 5, "Lena in Graysale")
_ = computeEntropy(camera, 5, "Lena RGB")

"""**Σχολιασμός:** Η εντροπία παρουσιάζει τοπικό ελάχιστο για μια μέση τιμή της παραμέτρου a στο διάστημα [0.2, ..., 1.0], η οποία (τυχαία) είναι ίδια και στις τρεις υπό εξέταση εικόνες. Συγκρίνοντας τις δυο είκονες της Λένα, RGB και Grayscale, παρατηρούμε ότι η εντροπία της δεύτερης προέκυψε μεγαλύτερη. Αυτό έρχεται σε αντιδιαστολή με αυτό που θα περιμέναμε. Λόγω του ότι η RGB εικόνα περιέχει περισσότερη πληροφορία αφού έχει τρία κανάλια για κάθε pixel, θα περιμέναμε να είχε μεγαλύτερη εντροπία. Βέβαια το αποτέλεσμα που βγάλαμε δεν καταρρίπτει αυτό που αναμέναμε καθώς η διαφορά στις τιμές είναι μηδαμινή. Περνώντας τώρα στην σύγκριση των δυο grayscale εικόνων, βλέπουμε ότι έχουν αρκετά παραπλήσια εντροπία. Μεγαλύτερη εντροπία δηλώνει μεγαλύτερη αβεβαιότητα και ποικιλία στις τιμές των pixel της, πράγμα που όντως επαληθεύεται έστω και για την μικρή διαφορά στις δυο grayscale εικόνες. Τα pixel της εικόνας 'camera' θα έλεγε κανείς ότι απλώνουν περισσότερο στο διάστημα [0, ..., 255], και άρα έστω και λίγο έχει μεγαλύτερη ποικιλομορφία στην απεικόνισή της, πράγμα που απαιτεί περισσότερα bits/pixel για την κωδικοποίηση της.

6. Για το βέλτιστο a, κβαντίζουμε τις εικόνες 'Lena' και 'camera' χρησιμοποιώντας διαφορετικά bin sizes.
"""

# Function that calculates the quantized Laplacian pyramid and the decoded one

# bins correspond to the intensity thresholds
def trialNo1(I, bin_sizes, a=0.55, depth=5, im_type='gray'):
  lapl_pyramid = LPyramid(I, a, depth) # Calc the Laplacian Pyramid
  #fig.suptitle(f'LPyramid of first image (Lena)')
  helperPyramid(lapl_pyramid, im_type)

  '''
  For each level of the pyramid, if we have for e.g. bins = 10, we discretize
  the interval [0, ..., 255] into 10 ranges of discrete values.
  '''
  decoded_I = []
  for num_bins in bin_sizes:
    fig, axes = plt.subplots(1, len(lapl_pyramid), figsize=(20, 5))
    fig.suptitle(f'Quantized LPyramid with {num_bins} bins')

    # We quantized the last level also
    quantized_pyr = [
        L_Quantization(lapl_pyramid[i], num_bins) for i in range(len(lapl_pyramid))
    ]

    for i, ax in enumerate(axes):
        if im_type == 'gray':
            ax.imshow(quantized_pyr[i], cmap='gray')
        else:
            ax.imshow(quantized_pyr[i]) # For RGB
        ax.set_title(f"Level {i}")

    plt.tight_layout()
    plt.show()

    # Reconstruct image from quantized pyramid
    decoded_image = L_Pyramid_Decode(quantized_pyr, a)
    decoded_I.append((num_bins, decoded_image))

  plt.figure(figsize=(15, depth+1))

  for i in range(len(decoded_I)):
      plt.subplot(1, len(decoded_I), i+1)
      plt.title(f'{decoded_I[i][0]} bins')

      if im_type == 'gray':
          plt.imshow(decoded_I[i][1], cmap='gray')
      else:  # For RGB images
          plt.imshow(decoded_I[i][1].astype(np.uint8))

      plt.axis('off')

  plt.suptitle('Comparison of Decoded Images with Different Bin Counts')
  plt.tight_layout()
  plt.show()

  return [quantized_pyr, decoded_I]

quantized_camera, dec_camera = trialNo1(camera, [10, 30, 100, 160, 256])

quantized_gray_lena, dec_gray_lena = trialNo1(gray_lena, [10, 30, 100, 160, 256])

quantized_RGB_lena, dec_RGB_lena = trialNo1(RGB_lena, [10, 30, 100, 160, 256], a=0.55, depth=5, im_type='color')

"""**Σχολιασμός:** Όπως μπορούμε να παρατηρήσουμε, όσο μικρότερη είναι η τμηματοποίηση του διαστήματος στο οποίο κβαντίζουμε την εικόνα (μικρό bin size), τόσο περισσότερο διαφέρει η ανακατασκευασμένη εικόνα από την αρχική. Αυτό είναι λογικό διότι όσο λιγότερα bins βάζουμε, σε τόσα λιγότερα 'Pixel' θα κβαντίσουμε την εικόνα. Βέλτιστη ανακατασκευή πετυχαίνουμε όταν επιτρέπουμε την ύπαρξη 256 bins, ένα δηλαδή για κάθε pixel (για 8-bit grayscale εικόνες). Παρόλα αυτά, ακόμα και με χαμηλό αριθμό από Bins βλέπουμε ότι μπορούμε να αναγνωρίσουμε την αρχική εικόνα από την ανακατασκευασμένη. Στην RGB συναντήσαμε μεγαλύτερη δυσκολία λόγω των τριών καναλιών πληροφορίας που έχει. Ακόμα και σε αυτή όμως, ήδη για 100 bin αναγνωρίζουμε πλήρως το εύρος χρωμάτων της εικόνας.

# Περαιτέρω εμβάθυνση με μετρικές για ανάδειξη των αποτελεσμάτων

Παρακάτω θα παρουσιάσουμε ενδιαφέρουσες μετρικές προκειμένου να αναδείξουμε τα συμπεράσματα που βγάλαμε. Συγκεκριμένα:
1. PSNR (Peak Signal-to-Noise-Ratio)
  - Μετράει την αναλογία μεταξύ της μέγιστης δυνατής ισχύος του σήματος και της ισχύος του θορύβου
  - Όσο υψηλότερη τιμή έχει, τόσο καλύτερη ποιότητα (σε dB)
  - Αυξάνεται με την αύξηση του αριθμού των bins που χρησιμοποιούμε
2. SSIM (Structural Similarity Index)
  - Μετρέι την ομοιότητα μεταξύ δυο εικόνων ως προς την φωτεινότητα, την αντίθεση και την δομή
  - Κυμαίνεται μεταξύ 0 και 1, με την τιμή 1 να δείχνει πλήρη ταύτιση
  - Βασίζεται στην ανθρώπινη ευαισθησία στις διαφορές
3. MAE (Mean Absolute Error)
  - Μέση απόλυτη διαφορά μεταξύ αρχικού και ανακατασκευασμένου pixel
4. MSE (Mean Squared Error)
  - Μέση τετραγωνική διαφορά μεταξύ αρχικού και ανακατασκευασμένου pixel
5. Compression Ratio
  - Υψηλότερες τιμές δείχνουν καλύτερη συμπίεση
  - Trade-off with quality, μικρότερος αριθμός από bins δίνει μεγαλύτερη συμπίεση αλλά μικρότερη ευκρίνεια
"""

def calculate_image_metrics(original, reconstructed, im_type='gray'):
    from skimage.metrics import peak_signal_noise_ratio, structural_similarity

    metrics = {}

    # Calculate PSNR
    metrics['psnr'] = peak_signal_noise_ratio(original, reconstructed)

    # Calculate SSIM (differently for grayscale vs. color)
    if im_type == 'gray':
        # For grayscale
        min_size = min(original.shape)
        if min_size < 7:
            win_size = min_size if min_size % 2 == 1 else min_size - 1
            metrics['ssim'] = structural_similarity(
                original, reconstructed,
                win_size=win_size,
                data_range=original.max() - original.min()
            )
        else:
            metrics['ssim'] = structural_similarity(
                original, reconstructed,
                data_range=original.max() - original.min()
            )
    else:
        # For ΡΓΒ
        min_size = min(original.shape[0], original.shape[1])
        if min_size < 7:
            win_size = min_size if min_size % 2 == 1 else min_size - 1
            metrics['ssim'] = structural_similarity(
                original, reconstructed,
                win_size=win_size,
                data_range=original.max() - original.min(),
                channel_axis=2
            )
        else:
            metrics['ssim'] = structural_similarity(
                original, reconstructed,
                data_range=original.max() - original.min(),
                channel_axis=2
            )

    # Mean Absolute Error
    metrics['mae'] = np.mean(np.abs(original - reconstructed))

    # Mean Squared Error
    metrics['mse'] = np.mean((original - reconstructed)**2)

    # Root Mean Squared Error
    metrics['rmse'] = np.sqrt(metrics['mse'])

    # Signal-to-Noise Ratio (SNR)
    signal_power = np.mean(original**2)
    noise_power = metrics['mse']
    metrics['snr'] = 10 * np.log10(signal_power / noise_power) if noise_power > 0 else float('inf')

    # Normalized Cross-Correlation
    original_mean = np.mean(original)
    reconstructed_mean = np.mean(reconstructed)
    numerator = np.sum((original - original_mean) * (reconstructed - reconstructed_mean))
    denominator = np.sqrt(np.sum((original - original_mean)**2) * np.sum((reconstructed - reconstructed_mean)**2))
    metrics['ncc'] = numerator / denominator if denominator > 0 else 0

    # Maximum Absolute Difference
    metrics['max_diff'] = np.max(np.abs(original - reconstructed))

    return metrics

def calculate_compression_metrics(original, quantized_pyramid, bin_size, im_type='gray'):
    metrics = {}

    # Calculate original image size in bits
    if im_type == 'gray':
        original_bits = original.size * 8
    else:
        original_bits = original.size * 8

    metrics['original_bits'] = original_bits

    # Calculate bits needed for quantized representation
    quantized_bits = 0
    entropy = 0

    for level in quantized_pyramid:
        # Calculate bits per pixel based on bin size
        bits_per_pixel = np.log2(bin_size)
        level_bits = bits_per_pixel * level.size
        quantized_bits += level_bits

    metrics['quantized_bits'] = quantized_bits
    metrics['bits_per_pixel'] = quantized_bits / original.size
    metrics['compression_ratio'] = original_bits / quantized_bits
    metrics['space_savings'] = 1 - (quantized_bits / original_bits)

    return metrics

def visualize_metrics(metrics_list, bin_sizes):

    plt.figure(figsize=(15, 12))

    plt.subplot(3, 2, 1)
    plt.plot(bin_sizes, [m['image_quality']['psnr'] for m in metrics_list], 'o-', label='PSNR')
    plt.xlabel('Number of Bins')
    plt.ylabel('PSNR (dB)')
    plt.title('Peak Signal-to-Noise Ratio')
    plt.grid(True)

    plt.subplot(3, 2, 2)
    plt.plot(bin_sizes, [m['image_quality']['ssim'] for m in metrics_list], 'o-', label='SSIM')
    plt.xlabel('Number of Bins')
    plt.ylabel('SSIM')
    plt.title('Structural Similarity Index')
    plt.grid(True)

    plt.subplot(3, 2, 3)
    plt.plot(bin_sizes, [m['image_quality']['mae'] for m in metrics_list], 'o-', label='MAE')
    plt.xlabel('Number of Bins')
    plt.ylabel('Mean Absolute Error')
    plt.title('Mean Absolute Error')
    plt.grid(True)

    plt.subplot(3, 2, 4)
    plt.plot(bin_sizes, [m['image_quality']['rmse'] for m in metrics_list], 'o-', label='RMSE')
    plt.xlabel('Number of Bins')
    plt.ylabel('Root Mean Squared Error')
    plt.title('Root Mean Squared Error')
    plt.grid(True)

    plt.subplot(3, 2, 5)
    plt.plot(bin_sizes, [m['compression']['compression_ratio'] for m in metrics_list], 'o-', label='Ratio')
    plt.xlabel('Number of Bins')
    plt.ylabel('Compression Ratio')
    plt.title('Compression Ratio')
    plt.grid(True)

    plt.subplot(3, 2, 6)
    plt.plot(bin_sizes, [m['compression']['space_savings'] * 100 for m in metrics_list], 'o-', label='Savings')
    plt.xlabel('Number of Bins')
    plt.ylabel('Space Savings (%)')
    plt.title('Space Savings')
    plt.grid(True)

    plt.tight_layout()
    plt.show()

    # Create a second figure with more metrics
    plt.figure(figsize=(15, 8))

    plt.subplot(2, 2, 1)
    plt.plot(bin_sizes, [m['image_quality']['ncc'] for m in metrics_list], 'o-', label='NCC')
    plt.xlabel('Number of Bins')
    plt.ylabel('Normalized Cross-Correlation')
    plt.title('Normalized Cross-Correlation')
    plt.grid(True)

    plt.subplot(2, 2, 2)
    plt.plot(bin_sizes, [m['image_quality']['max_diff'] for m in metrics_list], 'o-', label='Max Diff')
    plt.xlabel('Number of Bins')
    plt.ylabel('Maximum Absolute Difference')
    plt.title('Maximum Absolute Difference')
    plt.grid(True)

    plt.tight_layout()
    plt.show()

    # Create scatter plot of quality vs compression
    plt.figure(figsize=(10, 8))

    plt.subplot(2, 1, 1)
    plt.scatter([m['compression']['compression_ratio'] for m in metrics_list],
                [m['image_quality']['psnr'] for m in metrics_list],
                s=80, alpha=0.7)

    # Add labels to each point
    for i, bin_size in enumerate(bin_sizes):
        plt.annotate(f"{bin_size}",
                    (metrics_list[i]['compression']['compression_ratio'],
                     metrics_list[i]['image_quality']['psnr']),
                    textcoords="offset points",
                    xytext=(0,10),
                    ha='center')

    plt.xlabel('Compression Ratio')
    plt.ylabel('PSNR (dB)')
    plt.title('Quality vs Compression: PSNR')
    plt.grid(True)

    plt.subplot(2, 1, 2)
    plt.scatter([m['compression']['compression_ratio'] for m in metrics_list],
                [m['image_quality']['ssim'] for m in metrics_list],
                s=80, alpha=0.7)

    # Add labels to each point
    for i, bin_size in enumerate(bin_sizes):
        plt.annotate(f"{bin_size}",
                    (metrics_list[i]['compression']['compression_ratio'],
                     metrics_list[i]['image_quality']['ssim']),
                    textcoords="offset points",
                    xytext=(0,10),
                    ha='center')

    plt.xlabel('Compression Ratio')
    plt.ylabel('SSIM')
    plt.title('Quality vs Compression: SSIM')
    plt.grid(True)

    plt.tight_layout()
    plt.show()

all_metrics = []

bin_sizes = [10, 30, 100, 160, 256]

last_arrays = [array_data[-1] for _, array_data in dec_camera]

# Calculate metrics for each bin size
for idx, bin_size in enumerate(bin_sizes):

    image_metrics = calculate_image_metrics(camera, dec_camera[idx][1], 'gray')
    compression_metrics = calculate_compression_metrics(camera, quantized_camera, bin_size, 'gray')

    combined_metrics = {
        'bin_size': bin_size,
        'image_quality': image_metrics,
        'compression': compression_metrics
    }

    all_metrics.append(combined_metrics)

# Print summary for each bin size
for metrics in all_metrics:
    print(f"\n=== Summary for {metrics['bin_size']} bins ===")
    print(f"PSNR: {metrics['image_quality']['psnr']:.2f} dB")
    print(f"SSIM: {metrics['image_quality']['ssim']:.4f}")
    print(f"MAE: {metrics['image_quality']['mae']:.4f}")

visualize_metrics(all_metrics, bin_sizes)

all_metrics = []

bin_sizes = [10, 30, 100, 160, 256]

last_arrays = [array_data[-1] for _, array_data in dec_gray_lena]

# Calculate metrics for each bin size
for idx, bin_size in enumerate(bin_sizes):

    image_metrics = calculate_image_metrics(gray_lena, dec_gray_lena[idx][1], 'gray')
    compression_metrics = calculate_compression_metrics(gray_lena, quantized_gray_lena, bin_size, 'gray')

    combined_metrics = {
        'bin_size': bin_size,
        'image_quality': image_metrics,
        'compression': compression_metrics
    }

    all_metrics.append(combined_metrics)

# Print summary for each bin size
for metrics in all_metrics:
    print(f"\n=== Summary for {metrics['bin_size']} bins ===")
    print(f"PSNR: {metrics['image_quality']['psnr']:.2f} dB")
    print(f"SSIM: {metrics['image_quality']['ssim']:.4f}")
    print(f"MAE: {metrics['image_quality']['mae']:.4f}")

visualize_metrics(all_metrics, bin_sizes)

all_metrics = []

bin_sizes = [10, 30, 100, 160, 256]

last_arrays = [array_data[-1] for _, array_data in dec_RGB_lena]

# Calculate metrics for each bin size
for idx, bin_size in enumerate(bin_sizes):

    image_metrics = calculate_image_metrics(RGB_lena, dec_RGB_lena[idx][1], 'color')
    compression_metrics = calculate_compression_metrics(RGB_lena, quantized_RGB_lena, bin_size, 'color')

    combined_metrics = {
        'bin_size': bin_size,
        'image_quality': image_metrics,
        'compression': compression_metrics
    }

    all_metrics.append(combined_metrics)

# Print summary for each bin size
for metrics in all_metrics:
    print(f"\n=== Summary for {metrics['bin_size']} bins ===")
    print(f"PSNR: {metrics['image_quality']['psnr']:.2f} dB")
    print(f"SSIM: {metrics['image_quality']['ssim']:.4f}")
    print(f"MAE: {metrics['image_quality']['mae']:.4f}")

visualize_metrics(all_metrics, bin_sizes)